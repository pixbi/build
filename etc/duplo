#!/usr/bin/env bash

dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# Only makes sense for the top level to define CWD
if [ "$1" != "buildDep" ] && [ "$CWD" ]; then
  cwd="$( cd "$CWD" && pwd )"
else
  cwd="$(pwd)"
fi

duploGlobal="$dir/../lib/node_modules/duplo"
if [ -d "$duploGlobal" ]; then
  duplo="$( cd $duploGlobal && pwd )"
else
  duplo="$( cd "$dir/.." && pwd )"
fi

json="$duplo/node_modules/.bin/JSON.sh"
gulp="$duplo/node_modules/.bin/gulp"
gulpfile="$duplo/cli/gulpfile.js"
run="$gulp --base $duplo --gulpfile $gulpfile"
version='0.0.0'

abort() {
  printf "\n  \033[31mError: $@\033[0m\n\n" && exit 1
}

set_version() {
  eval "$3=`cat "$1/$2.json" | $json | egrep '\["version"\]' | egrep -o '[0-9\.]+'`"
}

display_version_string() {
  echo 'Duplo v'$version
}

display_help() {
  cat <<-EOF

  Usage: duplo [commands] [args]

  Commands:

    duplo new <name> <repo-url>      scaffolds a new duplo repo
    duplo dev                        starts a local server and re-compiles on 
                                     file change
    duplo build                      runs a build. This could be used for checking
                                     the code against Closure Compiler.
    duplo patch                      builds the project and bump the patch version
    duplo minor                      builds the project and bump the minor version
    duplo major                      builds the project and bump the major version

EOF
  exit 0
}

precommit() {
  git stash
  git checkout develop
}

commit() {
  ver='0.0.0'
  set_version $cwd component ver

  # Commit
  git add component.json
  git commit -m 'Bump version'
  # Merge into master
  git checkout master
  # Always force the new changes
  git merge develop -X theirs
  # Apply tag
  git tag $ver
  ## Sync with Github
  git push origin develop:develop
  git push origin master:master
  git push origin --tags
  # Go back to develop
  git checkout develop
}

# init version
set_version $duplo package version

case "$1" in
  version|ver|-v|--ver|--version)
    display_version_string
    ;;
  
  new)
    name=$2
    repo=$3

    if [ -z "$name" ]; then
      abort "There must be a name."
    fi
    if [ -z "$repo" ]; then
      abort "There must be a Git repo URL."
    fi

    # Make sure it's a Git repo
    git init
    # Main modules directory structure
    mkdir -p "$cwd/app/modules"
    # Asset directory
    mkdir -p "$cwd/app/assets"
    # Stylus directory
    mkdir -p "$cwd/app/styl"
    # Dev directory
    mkdir -p "$cwd/dev"
    # Component.IO
    echo '{"name":"'$name'","version":"0.0.0"}' > "$cwd/component.json"
    # We need a README
    echo "# $name" > "README.md"
    # Ignore files
    cat <<- EOF >> "$cwd/.gitignore"
public/
components/
tmp/
EOF
    # Initial commit
    git add .
    git commit -m "Initialized with duplo"
    # We need a develop branch
    git checkout -b develop
    # We need to set the repo
    git remote add origin $3
    # Confirm
    echo "Initialized with duplo"
    ;;

  dev)
    if [ -z "$NODE_ENV" ]; then
      NODE_ENV="dev"
    fi

    if [ -z "$2" ]; then
      CWD=$cwd NODE_ENV=$NODE_ENV BUILD_MODE=dev $run dev
    else
      CWD=$cwd NODE_ENV=$NODE_ENV BUILD_MODE=dev BUILD_FORM=$2 $run dev
    fi
    ;;
  
  build)
    if [ -z "$NODE_ENV" ]; then
      NODE_ENV="prod"
    fi

    if [ -z "$2" ]; then
      # build project/app
      CWD=$cwd NODE_ENV=$NODE_ENV BUILD_MODE=prod $run build
    else
      # build dep
      CWD=$cwd NODE_ENV=$NODE_ENV BUILD_MODE=prod BUILD_FORM=$2 $run build
    fi
    ;;

  patch|release)
    precommit && CWD=$cwd $run release:patch && commit
    ;;

  minor)
    precommit && CWD=$cwd $run release:minor && commit
    ;;

  major)
    precommit && CWD=$cwd $run release:major && commit
    ;;

  *)
    display_help
    ;;

esac
